/**
 * Created by Pieter Heyvaert, Data Science Lab (Ghent University - iMinds) on 27.01.16.
 */

const PrepareSourcesForRMLMapperCommand = function (callback) {

  this.execute = function () {
    const preparedSources = {};
    const sources = inputStore.getState().sources;

    for (let i in sources) {
      const source = sources[i];
      const data = source.data;
      console.log(source)
      console.log(data)

      for (let j in data) {
        delete data[j].id;
      }

      let preparedSourceData;

      if (source.type === "csv") {
        preparedSourceData = Papa.unparse(takeSampleCSV(source, APPLICATION_CONFIG.sampleSize), {delimiter: ","});
      } else if (source.type === "xml") {
        preparedSourceData = takeSampleXML(source, APPLICATION_CONFIG.sampleSize);
      } else if (source.type === "json") {
        preparedSourceData = takeSampleJSON(source, APPLICATION_CONFIG.sampleSize);
      }

      preparedSources[source.id] = preparedSourceData;
    }

    callback(preparedSources);
  };

  
};
/**
 * This recursively clips the CSV data.
 * @param {*} source Source of csv data
 * @param {*} amount Amount to clip on
 */
function takeSampleCSV(source, amount=1) {
  return source.data.slice(0,amount)
}

/**
 * This recursively clips the JSON data
 * @param {*} source Source of json data
 * @param {*} amount Amount to clip on
 */
function takeSampleJSON(source, amount=1) {
  const result = JSON.parse(source.data)
  const clip = (element) => {
    if(_.isObjectLike(element) && !_.isArray(element)) {
      return _.mapValues(element, (value) => clip(value))
    } else if (_.isArray(element)) {
      return element.slice(0, amount).map(el => clip(el))
    } else {
      return element
    }
  }
  return JSON.stringify(clip(result))
}
/**
 * This recursively clips the XML data
 * @param {*} source Source of XML data
 * @param {*} amount Amount to clip on
 */
function takeSampleXML(source, amount=1) {
  const parser = new DOMParser();
  const DOM = parser.parseFromString(source.data, "text/xml")
  console.log(DOM)
  window.XMLDOC = DOM;

  const clip = (element) => {
    const children = element.children;
    const groups = _.values(_.groupBy(children,(node)=>node.nodeName))
    groups.forEach(group => group.slice(amount).forEach(child => child.remove()))

    _.forEach(children, child => clip(child))
  }
  clip(DOM)
  console.log(DOM)
  return new XMLSerializer().serializeToString(DOM)
}
window.takeSampleCSV = takeSampleCSV;
window.takeSampleJSON = takeSampleJSON
window.takeSampleXML = takeSampleXML
const RunMappingCommand = function () {

  // Parse the results from one triplesmap, and add them to the results. Set those results.
  function parseMappingOutput(metadataStore, tmaps, mappingOutput) {
    let recognized = false;
    let violationLevel = "";
    let tmap;
    const results = [];

    for(let i = 0; i < mappingOutput.length; i++) {
      const subj = mappingOutput[i].subject;
      let pred = mappingOutput[i].predicate;
      const obj = mappingOutput[i].object;

      // Assume that all results in a file are mapped by the same triplesmap
      // If it is not yet known which triplesmap that is, check that.
      if (!recognized) {
        const subjs = metadataStore.getQuads(null, namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#subject"), subj).map(a => a.subject.value);
        const preds = metadataStore.getQuads(null, namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate"), pred).map(a => a.subject.value);
        const objs = metadataStore.getQuads(null, namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#object"), obj).map(a => a.subject);
        const same2 = [];

        for (let j = 0; j < subjs.length; j++) {
          for (let k = 0; k < preds.length; k++) {
            if (subjs[j] === preds[k]) same2.push(subjs[j]);
          }
        }

        let same3;

        for (let l = 0; l < objs.length && !recognized; l++) {
          for (let m = 0; m < same2.length && !recognized; m++) {
            if (objs[l].value === same2[m]) {
              recognized = true;
              same3 = objs[l];
            }
          }
        }

        // Set the desired violationlevel for the results generated by the triplesmap
        const triplesmap = metadataStore.getQuads(same3, "http://www.w3.org/ns/prov#wasDerivedFrom", null)[0].object.value;

        for (let n = 0; n < tmaps.length; n++) {
          if (triplesmap === tmaps[n].map) {
            violationLevel = tmaps[n].violationLevels;
            tmap = tmaps[n];
          }
        }

        if (! tmap) {
          console.warn(`No tmap was found for ${subj.value} ${pred.value} ${obj.value}`);
        }
      }

      if (pred === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
        pred = "a";
      }

      results.push({
        id: results.length + 1,
        subject: Util.collapsePrefix(subj.value),
        predicate: Util.collapsePrefix(pred.value),
        object: Util.collapsePrefix(obj.value),
        violationLevel: violationLevel,
        tmap: tmap
      });
    }

    CommandInvoker.getInvoker().execute(new SetResultsCommand(results, null));
  }

  // Parse the rml mapping data, in order to find out the amount of triplesMaps
  // and link a triplesMap with ids of graph entities.
  // If there are entities involved in a violation, the highest violationlevel is also associated with
  // the triplesMap.
  function parseMapDoc(data, preparedSources){
    const parser = N3.Parser();
    const store = N3.Store();

    parser.parse(data, function(error, quad, prefixes){
      if (quad) {
        store.addQuad(quad);
      } else {
        const tmaps = [];
        const triplesMaps = store.getQuads(null, null, namedNode("http://www.w3.org/ns/r2rml#TriplesMap"));

        for (let i = 0; i < triplesMaps.length; i++) {
          const tmap = {};
          tmap["map"] = triplesMaps[i].subject.value;
          const ids = [];
          // get subjectmap
          const subjectmaps = store.getQuads(triplesMaps[i].subject, namedNode("http://www.w3.org/ns/r2rml#subjectMap"), null).map(a => a.object);
          // get id's (corresponding to the correct entities) & link them with the triplesMap,
          // if they are not yet linked.
          for (let k = 0; k < subjectmaps.length; k++){
            const identifiers = store.getQuads(subjectmaps[k], namedNode(namespaces.dcterms + 'identifier'), null).map(a => a.object.value);

            identifiers.forEach(id => {
              ids.push(id);
            });
          }

          // get predobjmap
          const predobjmaps = store.getQuads(triplesMaps[i].subject, namedNode("http://www.w3.org/ns/r2rml#predicateObjectMap"), null).map(a => a.object);

          for (let j = 0; j < predobjmaps.length; j++) {
            // get predicate map and object map separately & link the id's with the triplesMap
            const predobjmap = predobjmaps[j];
            const objmaps = store.getQuads(predobjmap, namedNode("http://www.w3.org/ns/r2rml#objectMap"), null).map(a => a.object);

            for(let l = 0; l < objmaps.length; l++){
              const identifiers = store.getQuads(objmaps[l], namedNode(namespaces.dcterms + 'identifier'), null).map(a => a.object.value);

              identifiers.forEach(id => {
                ids.push(id);
              });
            }

            const predmaps = store.getQuads(predobjmap, namedNode("http://www.w3.org/ns/r2rml#predicateMap"), null).map(a => a.object);

            for(let m = 0; m < predmaps.length; m++){
              const identifiers = store.getQuads(predmaps[m], namedNode(namespaces.dcterms + 'identifier'), null).map(a => a.object.value);

              identifiers.forEach(id => {
                ids.push(id);
              });
            }
          }

          // check whether or not any graphIds are involved in any violations.
          // If so, get the highest violation level as well.
          const levels = [];
          const types = [];

          for (let n = 0; n < ids.length; n++){
            const graphid = ids[n];
            // node or edge
            let entity = visibleGraphStore.findNode(graphid);
            if (entity === null) entity = visibleGraphStore.findEdge(graphid);

            if (entity && entity.errors !== null && entity.errors.length > 0) {
              for(let o = 0; o < entity.errors.length; o++){
                if(levels.indexOf(entity.errors[o].errorLevel) < 0) levels.push(entity.errors[o].errorLevel);
                if(types.indexOf(entity.errors[o].code) < 0) types.push(entity.errors[o].code);
              }
            }
          }

          tmap["violationLevels"] = levels;
          tmap["violationTypes"] = types;
          tmap["ids"] = ids;
          tmaps.push(tmap);
        }

        $.ajax({
          type: "POST",
          url: APPLICATION_CONFIG.rmlprocessor.url + "/execute",
          data: JSON.stringify({
            rml: data,
            sources: preparedSources,
            generateMetadata: true,
            asQuads: false
          }),
          contentType: 'application/json; charset=utf-8',
          success: function (data) {
            let parser = N3.Parser();
            const metadataStore = N3.Store();
            const results = [];

            // Parse the received metadata and store it in the metadataStore
            parser.parse(data.metadata, function(error, quad, prefixes){
              if (quad) {
                metadataStore.addQuad(quad);
              } else {
                parser = N3.Parser();

                parser.parse(data.output, function(error, quad, prefixes){
                  if (quad) {
                    results.push(quad);
                  } else {
                    parseMappingOutput(metadataStore, tmaps, results);
                    $$("runmapping_popup").close();
                  }
                });
              }
            });
          },
          error: function (jqXHR, error) {
            $$("runmapping_popup").close();

            let message = 'We could not execute the mapping with the remote RMLMapper.';

            if (jqXHR.status === 0 ) {
              message = 'We could not find the remote RMLMapper. Is the server online?';
            } else if (jqXHR.status === 500) {
              message = 'Internal server when executing the remote RMLMapper.';
            }

            CommandInvoker.getInvoker().execute(new ShowErrorMessageCommand("Problem with RMLMapper", message));
          }
        });
      }
    });
  }

  this.execute = function () {
    const popup = webix.ui({
      id: "runmapping_popup",
      view: "popup",
      height: 75,
      width: 250,
      minWidth: 250,
      position: "center",
      head: "My Window",
      body: UIBuilder.getNoButtonModal("Mapping is running, please wait..."),
      modal: true
    });

    popup.show();

    CommandInvoker.getInvoker().execute(new PrepareSourcesForRMLMapperCommand(preparedSources => {
      const rmlWriter = new RMLWriter(preparedSources, graphStore.getState().nodes, graphStore.getState().edges);

      rmlWriter.write(rmlStr => {
        parseMapDoc(rmlStr, preparedSources);
      });
    }));
  };
};
